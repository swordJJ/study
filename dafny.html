<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Sword-Research Zone</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="index.html">Main</a></li>
							<li class="active"><a href="dafny.html">Dafny</a></li>
							<li><a href="murphi.html">Murphi</a></li>
							<li><a href="spin.html">Spin</a></li>
						</ul>
						<ul class="icons">
							<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
							<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
							<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
							<li><a href="#" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 7, 2020</span>
									<h1>Dafny 学习编码记录1</h1>
									<p>Dafny是一种旨在使编写正确代码变得容易的语言。在没有任何运行时错误的意义上，这意味着正确，但在实际执行程序员所期望的操作时也是正确的。为了实现这一点，Dafny依赖于高级注释来推理和证明代码的正确性。
										一段代码的效果可以抽象地给出，使用期望行为的自然、高级表达式，这样更容易编写，也更不容易出错。然后，Dafny生成一个证明，证明代码与注释匹配(当然，假设它们是正确的!)Dafny将编写无bug代码的负担提升到编写无bug注释的负担。这通常比编写代码更容易，因为注释更短更直接。
									</p>
								</header>
								<div class="image fit"><img src="images/dafny.jpg" alt="" /></div>
								<h3>Method规约</h3>
								<p>method是强制执行的代码，在其他语言里左脚procedures或者function，在Dafny，function保留为另一个不同的概念。<br>
								一个method段为：<br>
									method Abs(x:int) returns (y:int)<br>
									{<br>
										&nbsp&nbsp&nbsp&nbsp...<br>
									}<br>
								方法名为Abs，带有一个整型的参数x,返回一个整型y。参数后须跟:和类型。同时可以声明多个参数和多个返回类型。<br>
								method的主体是由花括号围起来的代码段。主体包括一系列的陈述句，如强制赋值，if语句，循环和其他method的调用，返回语句等。<br>
								<br>通过:=进行赋值，Dafny使用==进行相等，dafny没有一个等号的表达式。语句后面跟一个分号，空格和//或者/**/注释会被忽略。
								</p>
								<h3>Pre-和Postcondition规约</h3>
								<p>Dafny的强大之处是能够通过注解方法指定行为。如Abs方法的不论什么输入，其结果总是大于等于0。有了这个注解，Dafny可以证明我们声称方法的属性为真，Dafny有许多种方式给出注解，但最常用的最基础的就是方法Pre-和postconditions。<br>
									Postconditions，由ensures关键字给出，在返回值后，方法体前，作为method声明的一部分。ensures关键字后跟随一个布尔表达式。如：<br>
									method Abs(x:int) returns (y:int)<br>
									&nbsp&nbsp&nbsp&nbsp ensures 0<=y <br>
										{<br>
											&nbsp&nbsp&nbsp&nbsp...<br>
										}<br>
									通常来说，Dafny验证错误有两大原因，规约与代码不一致或者不够clever来证明所需属性成立。
									Preconditions与postcondition类似，在方法调用前必须为真。当编写方法的时候，你假设了前置条件，就必须设置后置条件。方法的调用就会假设当方法返回时，后置条件成立。<br>
									requires是precondtion的关键字。<br>
									method MultipleReturns(x:int,y:int) returns (more:int,less:int)<br>
									&nbsp&nbsp&nbsp&nbsprequires 0 < y<br>
									&nbsp&nbsp&nbsp&nbspensures less < x < more<br>
									{<br>
										&nbsp&nbsp&nbsp&nbspmore := x + y ;<br>
										&nbsp&nbsp&nbsp&nbspless := x - y ;<br>
									}<br>
								</p>
								<h3>Assertions</h3>
								<p>assert可以放在method的任意的位置，以关键字assert，跟随一个布尔表达式和分号终结。assert意味着当控制到达代码执行部位时，表达式总是成立。<br>
								method Testing()<br>
							{<br>
								&nbsp&nbsp&nbsp&nbsp assert 2 < 3;<br>
							}<br>
								局部变量表示为var x:int := 5;<br>或者var x:= 5;<br>多变量可以同时表示为：var x,y,z:bool := 1,2,true;<br>
								Note:Dafny调用方法不在意方法内部的执行过程，只知道method的返回值，没有更多的信息。除非加方法的后置条件。
								</p>
								<h3>Functions</h3>
								<p>function abs(x:int):int<br>
								{
									&nbsp&nbsp&nbsp&nbsp if x < 0 then -x else x<br>
								}<br>
								上面声明了一个叫做abs，带有一位int参数，返回值为int的函数。function body部分必须只包含一个表达式。function的优势在于可以直接在specifications中使用。如：<br>
								assert abs(3) == 3;<br>
								function不能作为最后的变异程序，它只是一个帮助我们验证代码的工具。function method可以在真实代码中调用。<br>
								Note:nat表示为自然数类型（无负整数)。
							</p>
								<h3>Loop invriants</h3>
								<p>Dafny的while loop有一个问题，即Dafny没有办法提前知道代码会执行多少次循环。但是Dafny需要考虑一个程序的所有路径，包括进入多少次循环。因此需要提供loop invariant注解。<br>
								loop invariant是一个进入循环、执行完每次循环体之后成立的表达式。如 i>=0 是下面循环的不变式:<br>
							method m(n:nat)<br>
						{<br>
							&nbsp&nbsp&nbsp&nbsp var i:=0;<br>
							&nbsp&nbsp&nbsp&nbsp while i < n 
							&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <br>
							&nbsp&nbsp&nbsp&nbsp{<br>
								&nbsp&nbsp&nbsp&nbsp i:= i+1;<br>
								&nbsp&nbsp&nbsp&nbsp}<br>
						}<br>
						当指定了不变时，Dafny证明两件事情，即不变式在进入循环前成立，并且由循环保留。
							</p>
								<h3>Termination</h3>
								<p>Dafny通过使用decreases注解证明代码终止。Dafny证明终止在两个地方:loops 和 递归。这两者要不需要一个显示的注解，要不由Dafny提供正确的猜测。<br>
								decreases注解表示每次循环或者递归调用完之后表达式下降。Dafny需要验证的两个条件：表达式确实变小了以及是有边界的。<br>
								while 0 < i <br>
								&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <br>
								&nbsp&nbsp&nbsp&nbsp decreases i <br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp i:=i-1;<br>
								}<br>
							</p>
								<h3>Arrays</h3>
								<p>Arrays是Dafny内置部分，如array<T>，其中T是另一种类型。 数组可以是null，已经有内置的长度域，a.Length。数组元素的访问从0开始，如a[0],a[1]等。边界检查是在验证时间中证明，no runtime checks。<br>
								</p>
								<h3>Quantifiers</h3>
								<p>quantifiers通常以forall表达式的形式出现，也叫做全称量词。bound variablt:对集合的元素引入了temporary name，也叫做边界变量，如下面的k：<br>
								assert forall k :: 0 <= k <a.Length ==> ...a[k]...</p>
								边界变量是由类型的，通常是int类型。一对::分离边界变量和可选类型到全称属性。
								<h3>Predicates</h3>predicate是一个返回boolean类型的function，它简单但是在Dafny程序中具有很重要的角色。如我们对整型类型的数组，定义一个sorted predicate，当且仅当数组是有序的并且以递增的顺序，则返回true。使用predicates会让我们的代码更短，不需要一遍一遍重续属性。可读性增强了。
								<br>
								predicate sorted(a:array<int>)<br>
									&nbsp&nbsp&nbsp&nbsp  requires a!=null<br>
									{<br>
										forall j,k :: 0<= j < k < a.Length ==> a[j]<=a[k]<br>
									}<br>
								<h3>Framing</h3>
								sorted predicate无法访问数组，因为数组没有包括在函数的reading frame中。函数或者predicate的reading frame是所有内存的分配地址，函数允许读。
								predicate sorted(a:array<int>)<br>
									...<br>
									reads a<br>
									...<br>
								reads注解与其他注解不同，不是一个布尔表达式，可以出现在pre-和postcondition之后。modifies注解允许对内存部分进行修改。
								Note:Framing只出现在heap或者内存上。局部便利不能存储在堆上，因此他们不能再reads中提及，set、sequences和multiset的类型为值，可以视为整数或者局部变量。数组和对象是引用类型，他们存储在堆上。
							</section>
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 9, 2020</span>
									<h1>Dafny 学习编码记录2</h1>

								</header>
							</section>
					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>