<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Sword-Research Zone</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo">Massively</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="index.html">Main</a></li>
							<li class="active"><a href="dafny.html">Dafny</a></li>
							<li><a href="murphi.html">Murphi</a></li>
							<li><a href="spin.html">Spin</a></li>
						</ul>
						<ul class="icons">
							<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
							<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
							<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
							<li><a href="#" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 7, 2020</span>
									<h1>Dafny 学习编码记录1</h1>
									<p>Dafny是一种旨在使编写正确代码变得容易的语言。在没有任何运行时错误的意义上，这意味着正确，但在实际执行程序员所期望的操作时也是正确的。为了实现这一点，Dafny依赖于高级注释来推理和证明代码的正确性。
										一段代码的效果可以抽象地给出，使用期望行为的自然、高级表达式，这样更容易编写，也更不容易出错。然后，Dafny生成一个证明，证明代码与注释匹配(当然，假设它们是正确的!)Dafny将编写无bug代码的负担提升到编写无bug注释的负担。这通常比编写代码更容易，因为注释更短更直接。
									</p>
								</header>
								<div class="image fit"><img src="images/dafny.jpg" alt="" /></div>
								<h3>Method规约</h3>
								<p>method是强制执行的代码，在其他语言里左脚procedures或者function，在Dafny，function保留为另一个不同的概念。<br>
								一个method段为：<br>
									method Abs(x:int) returns (y:int)<br>
									{<br>
										&nbsp&nbsp&nbsp&nbsp...<br>
									}<br>
								方法名为Abs，带有一个整型的参数x,返回一个整型y。参数后须跟:和类型。同时可以声明多个参数和多个返回类型。<br>
								method的主体是由花括号围起来的代码段。主体包括一系列的陈述句，如强制赋值，if语句，循环和其他method的调用，返回语句等。<br>
								<br>通过:=进行赋值，Dafny使用==进行相等，dafny没有一个等号的表达式。语句后面跟一个分号，空格和//或者/**/注释会被忽略。
								</p>
								<h3>Pre-和Postcondition规约</h3>
								<p>Dafny的强大之处是能够通过注解方法指定行为。如Abs方法的不论什么输入，其结果总是大于等于0。有了这个注解，Dafny可以证明我们声称方法的属性为真，Dafny有许多种方式给出注解，但最常用的最基础的就是方法Pre-和postconditions。<br>
									Postconditions，由ensures关键字给出，在返回值后，方法体前，作为method声明的一部分。ensures关键字后跟随一个布尔表达式。如：<br>
									method Abs(x:int) returns (y:int)<br>
									&nbsp&nbsp&nbsp&nbsp ensures 0<=y <br>
										{<br>
											&nbsp&nbsp&nbsp&nbsp...<br>
										}<br>
									通常来说，Dafny验证错误有两大原因，规约与代码不一致或者不够clever来证明所需属性成立。
									Preconditions与postcondition类似，在方法调用前必须为真。当编写方法的时候，你假设了前置条件，就必须设置后置条件。方法的调用就会假设当方法返回时，后置条件成立。<br>
									requires是precondtion的关键字。<br>
									method MultipleReturns(x:int,y:int) returns (more:int,less:int)<br>
									&nbsp&nbsp&nbsp&nbsprequires 0 < y<br>
									&nbsp&nbsp&nbsp&nbspensures less < x < more<br>
									{<br>
										&nbsp&nbsp&nbsp&nbspmore := x + y ;<br>
										&nbsp&nbsp&nbsp&nbspless := x - y ;<br>
									}<br>
								</p>
								<h3>Assertions</h3>
								<p>assert可以放在method的任意的位置，以关键字assert，跟随一个布尔表达式和分号终结。assert意味着当控制到达代码执行部位时，表达式总是成立。<br>
								method Testing()<br>
							{<br>
								&nbsp&nbsp&nbsp&nbsp assert 2 < 3;<br>
							}<br>
								局部变量表示为var x:int := 5;<br>或者var x:= 5;<br>多变量可以同时表示为：var x,y,z:bool := 1,2,true;<br>
								Note:Dafny调用方法不在意方法内部的执行过程，只知道method的返回值，没有更多的信息。除非加方法的后置条件。
								</p>
								<h3>Functions</h3>
								<p>function abs(x:int):int<br>
								{
									&nbsp&nbsp&nbsp&nbsp if x < 0 then -x else x<br>
								}<br>
								上面声明了一个叫做abs，带有一位int参数，返回值为int的函数。function body部分必须只包含一个表达式。function的优势在于可以直接在specifications中使用。如：<br>
								assert abs(3) == 3;<br>
								function不能作为最后的变异程序，它只是一个帮助我们验证代码的工具。function method可以在真实代码中调用。<br>
								Note:nat表示为自然数类型（无负整数)。
							</p>
								<h3>Loop invriants</h3>
								<p>Dafny的while loop有一个问题，即Dafny没有办法提前知道代码会执行多少次循环。但是Dafny需要考虑一个程序的所有路径，包括进入多少次循环。因此需要提供loop invariant注解。<br>
								loop invariant是一个进入循环、执行完每次循环体之后成立的表达式。如 i>=0 是下面循环的不变式:<br>
							method m(n:nat)<br>
						{<br>
							&nbsp&nbsp&nbsp&nbsp var i:=0;<br>
							&nbsp&nbsp&nbsp&nbsp while i < n 
							&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <br>
							&nbsp&nbsp&nbsp&nbsp{<br>
								&nbsp&nbsp&nbsp&nbsp i:= i+1;<br>
								&nbsp&nbsp&nbsp&nbsp}<br>
						}<br>
						当指定了不变时，Dafny证明两件事情，即不变式在进入循环前成立，并且由循环保留。
							</p>
								<h3>Termination</h3>
								<p>Dafny通过使用decreases注解证明代码终止。Dafny证明终止在两个地方:loops 和 递归。这两者要不需要一个显示的注解，要不由Dafny提供正确的猜测。<br>
								decreases注解表示每次循环或者递归调用完之后表达式下降。Dafny需要验证的两个条件：表达式确实变小了以及是有边界的。<br>
								while 0 < i <br>
								&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <br>
								&nbsp&nbsp&nbsp&nbsp decreases i <br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp i:=i-1;<br>
								}<br>
							</p>
								<h3>Arrays</h3>
								<p>Arrays是Dafny内置部分，如array<T>，其中T是另一种类型。 数组可以是null，已经有内置的长度域，a.Length。数组元素的访问从0开始，如a[0],a[1]等。边界检查是在验证时间中证明，no runtime checks。<br>
								</p>
								<h3>Quantifiers</h3>
								<p>quantifiers通常以forall表达式的形式出现，也叫做全称量词。bound variablt:对集合的元素引入了temporary name，也叫做边界变量，如下面的k：<br>
								assert forall k :: 0 <= k <a.Length ==> ...a[k]...</p>
								边界变量是由类型的，通常是int类型。一对::分离边界变量和可选类型到全称属性。
								<h3>Predicates</h3>predicate是一个返回boolean类型的function，它简单但是在Dafny程序中具有很重要的角色。如我们对整型类型的数组，定义一个sorted predicate，当且仅当数组是有序的并且以递增的顺序，则返回true。使用predicates会让我们的代码更短，不需要一遍一遍重续属性。可读性增强了。
								<br>
								predicate sorted(a:array<int>)<br>
									&nbsp&nbsp&nbsp&nbsp  requires a!=null<br>
									{<br>
										forall j,k :: 0<= j < k < a.Length ==> a[j]<=a[k]<br>
									}<br>
								<h3>Framing</h3>
								sorted predicate无法访问数组，因为数组没有包括在函数的reading frame中。函数或者predicate的reading frame是所有内存的分配地址，函数允许读。
								predicate sorted(a:array<int>)<br>
									...<br>
									reads a<br>
									...<br>
								reads注解与其他注解不同，不是一个布尔表达式，可以出现在pre-和postcondition之后。modifies注解允许对内存部分进行修改。
								Note:Framing只出现在heap或者内存上。局部便利不能存储在堆上，因此他们不能再reads中提及，set、sequences和multiset的类型为值，可以视为整数或者局部变量。数组和对象是引用类型，他们存储在堆上。
							</section>
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 9, 2020</span>
									<h1>Dafny 学习编码记录2</h1>
								</header>
								<h3>Termination</h3>
								Dafny证明所有程序的终止。非终结即（发散）行为有两个源头：循环、递归函数和方法。Dafny使用一个技术来解决任一情况：decreases annotations。

								decreaseas注解指定一个值叫做termination measure，在每次遍历循环或者递归函数方法的调用，严格变小。这个值是有边界的不能永远变小。如果值开始在任一无限值上，循环或者递归必须停止。为了证明这个，Dafny证明termination measure在每次迭代中变小。如果Dafny不能证明，就说错误发生在下降termination measure。因为每个termination measure都有一个内置的下边界。如：
								<br>while i < n <br>
								&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <= n <br>
								{<br>
									i := i + 1 ;<br>
								}<br>
								给定循环形式，Dafny有特殊的规则来猜termination measure。看到循环条件有A < B 的比较形式，则猜测 decreases B - A <br>
								在上述例子中则是，decreases n - i <br>
								对于循环可能不会终止或者终止的证明是未知的，有:<br>
								method hail(N: nat)<br>
								&nbsp&nbsp&nbsp&nbsp decreases *<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp var n := N;<br>
									&nbsp&nbsp&nbsp&nbsp while 1 < n<br>
									&nbsp&nbsp&nbsp&nbsp decreases *<br>
									&nbsp&nbsp&nbsp&nbsp { <br>
										&nbsp&nbsp&nbsp&nbsp n := if n % 2 == 0 then n / 2 else n * 3 + 1;<br>
										&nbsp&nbsp&nbsp&nbsp }<br>
								}<br>
								其中，Dafny提供了“out“，特殊的注解，dafny不会试图去证明终止。以decreases * 标记。<br>
								下面给出几个decreases例子：
								function Ack(m: nat, n: nat): nat<br>
								decreases m, n<br>
							 {<br>
								&nbsp&nbsp&nbsp&nbsp if m == 0 then n + 1<br>
								&nbsp&nbsp&nbsp&nbsp else if n == 0 then Ack(m - 1, 1)<br>
								&nbsp&nbsp&nbsp&nbsp else Ack(m - 1, Ack(m, n - 1))<br>
							 }<br>
							Termination 不仅应用在单个functions/methods上，也可以在多个相互递归functions/methods上。如：<br>
							predicate even(n: nat)<br>
							&nbsp&nbsp&nbsp&nbsp ensures even(n) <==> n % 2 == 0<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp if n == 0 then true else odd(n-1)<br>
								}<br>
								predicate odd(n: nat)<br>
								&nbsp&nbsp&nbsp&nbsp ensures odd(n) <==> n % 2 != 0<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp if n == 0 then false else even(n-1)<br>
								}	<br>
							</section>
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 10, 2020</span>
									<h1>Dafny 学习编码记录3</h1>
								</header>
								<h3>Sets</h3>
								不同类型的Set是Dafny验证的核心工具之一。Sets表示没有重复的无序元素集合。和Sequence类似，set是不可变的值类型。Set一旦创建，不能再被修改。Set对整数有以下类型:set<int>。总的来说，sets可以是任何类型，包括对象。具体的Set可以显示的表示：<br>
									var s1 := {}; // the empty set <br>
									var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 <br> 
									assert s2 == {1,1,2,3,3,3,3}; // same as before <br> 
									var s3, s4 := {1,2}, {1,4};	<br>
								其他的普通的集合操作：<br>
								assert s2 + s4 == {1,2,3,4}; // set union <br> 
								assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection <br> 
								assert s2 - s3 == {3}; // set difference <br> 
								因为集合只能仅包含最多一份每个元素，union不能多次计算重复的元素。两个有限集合操作数构成一个有限集合。集合的操作符永远有定义。<br>
								assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset <br> 
								assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset <br> 
								assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation <br> 
								assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality <br> 
								集合可以用in和！in测试元素在不在集合中。<br>
								assert 5 in {1,3,4,5};<br> 
								assert 1 in {1,3,4,5};<br> 
								assert 2 !in {1,3,4,5};<br> 
								assert forall x :: x !in {};<br> 
								集合可以使用reads和modifies条例。当使用decreases子句是，集合由子集有序表示。借助集合的理解来创建集合。通过包含f(x)来为所有类型为T的x满足p(x)：
								<br>   set x: T | p(x) :: f(x)<br>
								｜是用来分离谓词p和有界变量x。结果集的元素类型就是f(x)的返回值类型。如下:<br>
								assert (set x | x in {0,1,2} :: x * 1) == {0,1,2}; <br>
								assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};<br>
								assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};<br>

					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>