<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Sword-Research Zone</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo">DAFNY</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="index.html">Main</a></li>
							<li class="active"><a href="dafny.html">Dafny</a></li>
							<li><a href="murphi.html">Murphi</a></li>
							<li><a href="paper.html">Paper</a></li>
						</ul>
						<ul class="icons">
							<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
							<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
							<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
							<li><a href="#" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 7, 2020</span>
									<h1>Dafny å­¦ä¹ ç¼–ç è®°å½•1</h1>
									<p>Dafnyæ˜¯ä¸€ç§æ—¨åœ¨ä½¿ç¼–å†™æ­£ç¡®ä»£ç å˜å¾—å®¹æ˜“çš„è¯­è¨€ã€‚åœ¨æ²¡æœ‰ä»»ä½•è¿è¡Œæ—¶é”™è¯¯çš„æ„ä¹‰ä¸Šï¼Œè¿™æ„å‘³ç€æ­£ç¡®ï¼Œä½†åœ¨å®é™…æ‰§è¡Œç¨‹åºå‘˜æ‰€æœŸæœ›çš„æ“ä½œæ—¶ä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼ŒDafnyä¾èµ–äºé«˜çº§æ³¨é‡Šæ¥æ¨ç†å’Œè¯æ˜ä»£ç çš„æ­£ç¡®æ€§ã€‚
										ä¸€æ®µä»£ç çš„æ•ˆæœå¯ä»¥æŠ½è±¡åœ°ç»™å‡ºï¼Œä½¿ç”¨æœŸæœ›è¡Œä¸ºçš„è‡ªç„¶ã€é«˜çº§è¡¨è¾¾å¼ï¼Œè¿™æ ·æ›´å®¹æ˜“ç¼–å†™ï¼Œä¹Ÿæ›´ä¸å®¹æ˜“å‡ºé”™ã€‚ç„¶åï¼ŒDafnyç”Ÿæˆä¸€ä¸ªè¯æ˜ï¼Œè¯æ˜ä»£ç ä¸æ³¨é‡ŠåŒ¹é…(å½“ç„¶ï¼Œå‡è®¾å®ƒä»¬æ˜¯æ­£ç¡®çš„!)Dafnyå°†ç¼–å†™æ— bugä»£ç çš„è´Ÿæ‹…æå‡åˆ°ç¼–å†™æ— bugæ³¨é‡Šçš„è´Ÿæ‹…ã€‚è¿™é€šå¸¸æ¯”ç¼–å†™ä»£ç æ›´å®¹æ˜“ï¼Œå› ä¸ºæ³¨é‡Šæ›´çŸ­æ›´ç›´æ¥ã€‚
									</p>
								</header>
								<div class="image fit"><img src="images/dafny.jpg" alt="" /></div>
								<h3>Methodè§„çº¦</h3>
								<p>methodæ˜¯å¼ºåˆ¶æ‰§è¡Œçš„ä»£ç ï¼Œåœ¨å…¶ä»–è¯­è¨€é‡Œå·¦è„šproceduresæˆ–è€…functionï¼Œåœ¨Dafnyï¼Œfunctionä¿ç•™ä¸ºå¦ä¸€ä¸ªä¸åŒçš„æ¦‚å¿µã€‚<br>
								ä¸€ä¸ªmethodæ®µä¸ºï¼š<br>
									method Abs(x:int) returns (y:int)<br>
									{<br>
										&nbsp&nbsp&nbsp&nbsp...<br>
									}<br>
								æ–¹æ³•åä¸ºAbsï¼Œå¸¦æœ‰ä¸€ä¸ªæ•´å‹çš„å‚æ•°x,è¿”å›ä¸€ä¸ªæ•´å‹yã€‚å‚æ•°åé¡»è·Ÿ:å’Œç±»å‹ã€‚åŒæ—¶å¯ä»¥å£°æ˜å¤šä¸ªå‚æ•°å’Œå¤šä¸ªè¿”å›ç±»å‹ã€‚<br>
								methodçš„ä¸»ä½“æ˜¯ç”±èŠ±æ‹¬å·å›´èµ·æ¥çš„ä»£ç æ®µã€‚ä¸»ä½“åŒ…æ‹¬ä¸€ç³»åˆ—çš„é™ˆè¿°å¥ï¼Œå¦‚å¼ºåˆ¶èµ‹å€¼ï¼Œifè¯­å¥ï¼Œå¾ªç¯å’Œå…¶ä»–methodçš„è°ƒç”¨ï¼Œè¿”å›è¯­å¥ç­‰ã€‚<br>
								<br>é€šè¿‡:=è¿›è¡Œèµ‹å€¼ï¼ŒDafnyä½¿ç”¨==è¿›è¡Œç›¸ç­‰ï¼Œdafnyæ²¡æœ‰ä¸€ä¸ªç­‰å·çš„è¡¨è¾¾å¼ã€‚è¯­å¥åé¢è·Ÿä¸€ä¸ªåˆ†å·ï¼Œç©ºæ ¼å’Œ//æˆ–è€…/**/æ³¨é‡Šä¼šè¢«å¿½ç•¥ã€‚
								</p>
								<h3>Pre-å’ŒPostconditionè§„çº¦</h3>
								<p>Dafnyçš„å¼ºå¤§ä¹‹å¤„æ˜¯èƒ½å¤Ÿé€šè¿‡æ³¨è§£æ–¹æ³•æŒ‡å®šè¡Œä¸ºã€‚å¦‚Absæ–¹æ³•çš„ä¸è®ºä»€ä¹ˆè¾“å…¥ï¼Œå…¶ç»“æœæ€»æ˜¯å¤§äºç­‰äº0ã€‚æœ‰äº†è¿™ä¸ªæ³¨è§£ï¼ŒDafnyå¯ä»¥è¯æ˜æˆ‘ä»¬å£°ç§°æ–¹æ³•çš„å±æ€§ä¸ºçœŸï¼ŒDafnyæœ‰è®¸å¤šç§æ–¹å¼ç»™å‡ºæ³¨è§£ï¼Œä½†æœ€å¸¸ç”¨çš„æœ€åŸºç¡€çš„å°±æ˜¯æ–¹æ³•Pre-å’Œpostconditionsã€‚<br>
									Postconditionsï¼Œç”±ensureså…³é”®å­—ç»™å‡ºï¼Œåœ¨è¿”å›å€¼åï¼Œæ–¹æ³•ä½“å‰ï¼Œä½œä¸ºmethodå£°æ˜çš„ä¸€éƒ¨åˆ†ã€‚ensureså…³é”®å­—åè·Ÿéšä¸€ä¸ªå¸ƒå°”è¡¨è¾¾å¼ã€‚å¦‚ï¼š<br>
									method Abs(x:int) returns (y:int)<br>
									&nbsp&nbsp&nbsp&nbsp ensures 0<=y <br>
										{<br>
											&nbsp&nbsp&nbsp&nbsp...<br>
										}<br>
									é€šå¸¸æ¥è¯´ï¼ŒDafnyéªŒè¯é”™è¯¯æœ‰ä¸¤å¤§åŸå› ï¼Œè§„çº¦ä¸ä»£ç ä¸ä¸€è‡´æˆ–è€…ä¸å¤Ÿcleveræ¥è¯æ˜æ‰€éœ€å±æ€§æˆç«‹ã€‚
									Preconditionsä¸postconditionç±»ä¼¼ï¼Œåœ¨æ–¹æ³•è°ƒç”¨å‰å¿…é¡»ä¸ºçœŸã€‚å½“ç¼–å†™æ–¹æ³•çš„æ—¶å€™ï¼Œä½ å‡è®¾äº†å‰ç½®æ¡ä»¶ï¼Œå°±å¿…é¡»è®¾ç½®åç½®æ¡ä»¶ã€‚æ–¹æ³•çš„è°ƒç”¨å°±ä¼šå‡è®¾å½“æ–¹æ³•è¿”å›æ—¶ï¼Œåç½®æ¡ä»¶æˆç«‹ã€‚<br>
									requiresæ˜¯precondtionçš„å…³é”®å­—ã€‚<br>
									method MultipleReturns(x:int,y:int) returns (more:int,less:int)<br>
									&nbsp&nbsp&nbsp&nbsprequires 0 < y<br>
									&nbsp&nbsp&nbsp&nbspensures less < x < more<br>
									{<br>
										&nbsp&nbsp&nbsp&nbspmore := x + y ;<br>
										&nbsp&nbsp&nbsp&nbspless := x - y ;<br>
									}<br>
								</p>
								<h3>Assertions</h3>
								<p>assertå¯ä»¥æ”¾åœ¨methodçš„ä»»æ„çš„ä½ç½®ï¼Œä»¥å…³é”®å­—assertï¼Œè·Ÿéšä¸€ä¸ªå¸ƒå°”è¡¨è¾¾å¼å’Œåˆ†å·ç»ˆç»“ã€‚assertæ„å‘³ç€å½“æ§åˆ¶åˆ°è¾¾ä»£ç æ‰§è¡Œéƒ¨ä½æ—¶ï¼Œè¡¨è¾¾å¼æ€»æ˜¯æˆç«‹ã€‚<br>
								method Testing()<br>
							{<br>
								&nbsp&nbsp&nbsp&nbsp assert 2 < 3;<br>
							}<br>
								å±€éƒ¨å˜é‡è¡¨ç¤ºä¸ºvar x:int := 5;<br>æˆ–è€…var x:= 5;<br>å¤šå˜é‡å¯ä»¥åŒæ—¶è¡¨ç¤ºä¸ºï¼švar x,y,z:bool := 1,2,true;<br>
								Note:Dafnyè°ƒç”¨æ–¹æ³•ä¸åœ¨æ„æ–¹æ³•å†…éƒ¨çš„æ‰§è¡Œè¿‡ç¨‹ï¼ŒåªçŸ¥é“methodçš„è¿”å›å€¼ï¼Œæ²¡æœ‰æ›´å¤šçš„ä¿¡æ¯ã€‚é™¤éåŠ æ–¹æ³•çš„åç½®æ¡ä»¶ã€‚
								</p>
								<h3>Functions</h3>
								<p>function abs(x:int):int<br>
								{
									&nbsp&nbsp&nbsp&nbsp if x < 0 then -x else x<br>
								}<br>
								ä¸Šé¢å£°æ˜äº†ä¸€ä¸ªå«åšabsï¼Œå¸¦æœ‰ä¸€ä½intå‚æ•°ï¼Œè¿”å›å€¼ä¸ºintçš„å‡½æ•°ã€‚function bodyéƒ¨åˆ†å¿…é¡»åªåŒ…å«ä¸€ä¸ªè¡¨è¾¾å¼ã€‚functionçš„ä¼˜åŠ¿åœ¨äºå¯ä»¥ç›´æ¥åœ¨specificationsä¸­ä½¿ç”¨ã€‚å¦‚ï¼š<br>
								assert abs(3) == 3;<br>
								functionä¸èƒ½ä½œä¸ºæœ€åçš„å˜å¼‚ç¨‹åºï¼Œå®ƒåªæ˜¯ä¸€ä¸ªå¸®åŠ©æˆ‘ä»¬éªŒè¯ä»£ç çš„å·¥å…·ã€‚function methodå¯ä»¥åœ¨çœŸå®ä»£ç ä¸­è°ƒç”¨ã€‚<br>
								Note:natè¡¨ç¤ºä¸ºè‡ªç„¶æ•°ç±»å‹ï¼ˆæ— è´Ÿæ•´æ•°)ã€‚
							</p>
								<h3>Loop invriants</h3>
								<p>Dafnyçš„while loopæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå³Dafnyæ²¡æœ‰åŠæ³•æå‰çŸ¥é“ä»£ç ä¼šæ‰§è¡Œå¤šå°‘æ¬¡å¾ªç¯ã€‚ä½†æ˜¯Dafnyéœ€è¦è€ƒè™‘ä¸€ä¸ªç¨‹åºçš„æ‰€æœ‰è·¯å¾„ï¼ŒåŒ…æ‹¬è¿›å…¥å¤šå°‘æ¬¡å¾ªç¯ã€‚å› æ­¤éœ€è¦æä¾›loop invariantæ³¨è§£ã€‚<br>
								loop invariantæ˜¯ä¸€ä¸ªè¿›å…¥å¾ªç¯ã€æ‰§è¡Œå®Œæ¯æ¬¡å¾ªç¯ä½“ä¹‹åæˆç«‹çš„è¡¨è¾¾å¼ã€‚å¦‚ i>=0 æ˜¯ä¸‹é¢å¾ªç¯çš„ä¸å˜å¼:<br>
							method m(n:nat)<br>
						{<br>
							&nbsp&nbsp&nbsp&nbsp var i:=0;<br>
							&nbsp&nbsp&nbsp&nbsp while i < n 
							&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <br>
							&nbsp&nbsp&nbsp&nbsp{<br>
								&nbsp&nbsp&nbsp&nbsp i:= i+1;<br>
								&nbsp&nbsp&nbsp&nbsp}<br>
						}<br>
						å½“æŒ‡å®šäº†ä¸å˜æ—¶ï¼ŒDafnyè¯æ˜ä¸¤ä»¶äº‹æƒ…ï¼Œå³ä¸å˜å¼åœ¨è¿›å…¥å¾ªç¯å‰æˆç«‹ï¼Œå¹¶ä¸”ç”±å¾ªç¯ä¿ç•™ã€‚
							</p>
								<h3>Termination</h3>
								<p>Dafnyé€šè¿‡ä½¿ç”¨decreasesæ³¨è§£è¯æ˜ä»£ç ç»ˆæ­¢ã€‚Dafnyè¯æ˜ç»ˆæ­¢åœ¨ä¸¤ä¸ªåœ°æ–¹:loops å’Œ é€’å½’ã€‚è¿™ä¸¤è€…è¦ä¸éœ€è¦ä¸€ä¸ªæ˜¾ç¤ºçš„æ³¨è§£ï¼Œè¦ä¸ç”±Dafnyæä¾›æ­£ç¡®çš„çŒœæµ‹ã€‚<br>
								decreasesæ³¨è§£è¡¨ç¤ºæ¯æ¬¡å¾ªç¯æˆ–è€…é€’å½’è°ƒç”¨å®Œä¹‹åè¡¨è¾¾å¼ä¸‹é™ã€‚Dafnyéœ€è¦éªŒè¯çš„ä¸¤ä¸ªæ¡ä»¶ï¼šè¡¨è¾¾å¼ç¡®å®å˜å°äº†ä»¥åŠæ˜¯æœ‰è¾¹ç•Œçš„ã€‚<br>
								while 0 < i <br>
								&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <br>
								&nbsp&nbsp&nbsp&nbsp decreases i <br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp i:=i-1;<br>
								}<br>
							</p>
								<h3>Arrays</h3>
								<p>Arraysæ˜¯Dafnyå†…ç½®éƒ¨åˆ†ï¼Œå¦‚array<T>ï¼Œå…¶ä¸­Tæ˜¯å¦ä¸€ç§ç±»å‹ã€‚ æ•°ç»„å¯ä»¥æ˜¯nullï¼Œå·²ç»æœ‰å†…ç½®çš„é•¿åº¦åŸŸï¼Œa.Lengthã€‚æ•°ç»„å…ƒç´ çš„è®¿é—®ä»0å¼€å§‹ï¼Œå¦‚a[0],a[1]ç­‰ã€‚è¾¹ç•Œæ£€æŸ¥æ˜¯åœ¨éªŒè¯æ—¶é—´ä¸­è¯æ˜ï¼Œno runtime checksã€‚<br>
								</p>
								<h3>Quantifiers</h3>
								<p>quantifiersé€šå¸¸ä»¥forallè¡¨è¾¾å¼çš„å½¢å¼å‡ºç°ï¼Œä¹Ÿå«åšå…¨ç§°é‡è¯ã€‚bound variablt:å¯¹é›†åˆçš„å…ƒç´ å¼•å…¥äº†temporary nameï¼Œä¹Ÿå«åšè¾¹ç•Œå˜é‡ï¼Œå¦‚ä¸‹é¢çš„kï¼š<br>
								assert forall k :: 0 <= k <a.Length ==> ...a[k]...</p>
								è¾¹ç•Œå˜é‡æ˜¯ç”±ç±»å‹çš„ï¼Œé€šå¸¸æ˜¯intç±»å‹ã€‚ä¸€å¯¹::åˆ†ç¦»è¾¹ç•Œå˜é‡å’Œå¯é€‰ç±»å‹åˆ°å…¨ç§°å±æ€§ã€‚
								<h3>Predicates</h3>predicateæ˜¯ä¸€ä¸ªè¿”å›booleanç±»å‹çš„functionï¼Œå®ƒç®€å•ä½†æ˜¯åœ¨Dafnyç¨‹åºä¸­å…·æœ‰å¾ˆé‡è¦çš„è§’è‰²ã€‚å¦‚æˆ‘ä»¬å¯¹æ•´å‹ç±»å‹çš„æ•°ç»„ï¼Œå®šä¹‰ä¸€ä¸ªsorted predicateï¼Œå½“ä¸”ä»…å½“æ•°ç»„æ˜¯æœ‰åºçš„å¹¶ä¸”ä»¥é€’å¢çš„é¡ºåºï¼Œåˆ™è¿”å›trueã€‚ä½¿ç”¨predicatesä¼šè®©æˆ‘ä»¬çš„ä»£ç æ›´çŸ­ï¼Œä¸éœ€è¦ä¸€éä¸€éé‡ç»­å±æ€§ã€‚å¯è¯»æ€§å¢å¼ºäº†ã€‚
								<br>
								predicate sorted(a:array<int>)<br>
									&nbsp&nbsp&nbsp&nbsp  requires a!=null<br>
									{<br>
										forall j,k :: 0<= j < k < a.Length ==> a[j]<=a[k]<br>
									}<br>
								<h3>Framing</h3>
								sorted predicateæ— æ³•è®¿é—®æ•°ç»„ï¼Œå› ä¸ºæ•°ç»„æ²¡æœ‰åŒ…æ‹¬åœ¨å‡½æ•°çš„reading frameä¸­ã€‚å‡½æ•°æˆ–è€…predicateçš„reading frameæ˜¯æ‰€æœ‰å†…å­˜çš„åˆ†é…åœ°å€ï¼Œå‡½æ•°å…è®¸è¯»ã€‚
								predicate sorted(a:array<int>)<br>
									...<br>
									reads a<br>
									...<br>
								readsæ³¨è§£ä¸å…¶ä»–æ³¨è§£ä¸åŒï¼Œä¸æ˜¯ä¸€ä¸ªå¸ƒå°”è¡¨è¾¾å¼ï¼Œå¯ä»¥å‡ºç°åœ¨pre-å’Œpostconditionä¹‹åã€‚modifiesæ³¨è§£å…è®¸å¯¹å†…å­˜éƒ¨åˆ†è¿›è¡Œä¿®æ”¹ã€‚
								Note:Framingåªå‡ºç°åœ¨heapæˆ–è€…å†…å­˜ä¸Šã€‚å±€éƒ¨ä¾¿åˆ©ä¸èƒ½å­˜å‚¨åœ¨å †ä¸Šï¼Œå› æ­¤ä»–ä»¬ä¸èƒ½å†readsä¸­æåŠï¼Œsetã€sequenceså’Œmultisetçš„ç±»å‹ä¸ºå€¼ï¼Œå¯ä»¥è§†ä¸ºæ•´æ•°æˆ–è€…å±€éƒ¨å˜é‡ã€‚æ•°ç»„å’Œå¯¹è±¡æ˜¯å¼•ç”¨ç±»å‹ï¼Œä»–ä»¬å­˜å‚¨åœ¨å †ä¸Šã€‚
							</section>
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 9, 2020</span>
									<h1>Dafny å­¦ä¹ ç¼–ç è®°å½•2</h1>
								</header>
								<h3>Termination</h3>
								Dafnyè¯æ˜æ‰€æœ‰ç¨‹åºçš„ç»ˆæ­¢ã€‚éç»ˆç»“å³ï¼ˆå‘æ•£ï¼‰è¡Œä¸ºæœ‰ä¸¤ä¸ªæºå¤´ï¼šå¾ªç¯ã€é€’å½’å‡½æ•°å’Œæ–¹æ³•ã€‚Dafnyä½¿ç”¨ä¸€ä¸ªæŠ€æœ¯æ¥è§£å†³ä»»ä¸€æƒ…å†µï¼šdecreases annotationsã€‚

								decreaseasæ³¨è§£æŒ‡å®šä¸€ä¸ªå€¼å«åštermination measureï¼Œåœ¨æ¯æ¬¡éå†å¾ªç¯æˆ–è€…é€’å½’å‡½æ•°æ–¹æ³•çš„è°ƒç”¨ï¼Œä¸¥æ ¼å˜å°ã€‚è¿™ä¸ªå€¼æ˜¯æœ‰è¾¹ç•Œçš„ä¸èƒ½æ°¸è¿œå˜å°ã€‚å¦‚æœå€¼å¼€å§‹åœ¨ä»»ä¸€æ— é™å€¼ä¸Šï¼Œå¾ªç¯æˆ–è€…é€’å½’å¿…é¡»åœæ­¢ã€‚ä¸ºäº†è¯æ˜è¿™ä¸ªï¼ŒDafnyè¯æ˜termination measureåœ¨æ¯æ¬¡è¿­ä»£ä¸­å˜å°ã€‚å¦‚æœDafnyä¸èƒ½è¯æ˜ï¼Œå°±è¯´é”™è¯¯å‘ç”Ÿåœ¨ä¸‹é™termination measureã€‚å› ä¸ºæ¯ä¸ªtermination measureéƒ½æœ‰ä¸€ä¸ªå†…ç½®çš„ä¸‹è¾¹ç•Œã€‚å¦‚ï¼š
								<br>while i < n <br>
								&nbsp&nbsp&nbsp&nbsp invariant 0 <= i <= n <br>
								{<br>
									i := i + 1 ;<br>
								}<br>
								ç»™å®šå¾ªç¯å½¢å¼ï¼ŒDafnyæœ‰ç‰¹æ®Šçš„è§„åˆ™æ¥çŒœtermination measureã€‚çœ‹åˆ°å¾ªç¯æ¡ä»¶æœ‰A < B çš„æ¯”è¾ƒå½¢å¼ï¼Œåˆ™çŒœæµ‹ decreases B - A <br>
								åœ¨ä¸Šè¿°ä¾‹å­ä¸­åˆ™æ˜¯ï¼Œdecreases n - i <br>
								å¯¹äºå¾ªç¯å¯èƒ½ä¸ä¼šç»ˆæ­¢æˆ–è€…ç»ˆæ­¢çš„è¯æ˜æ˜¯æœªçŸ¥çš„ï¼Œæœ‰:<br>
								method hail(N: nat)<br>
								&nbsp&nbsp&nbsp&nbsp decreases *<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp var n := N;<br>
									&nbsp&nbsp&nbsp&nbsp while 1 < n<br>
									&nbsp&nbsp&nbsp&nbsp decreases *<br>
									&nbsp&nbsp&nbsp&nbsp { <br>
										&nbsp&nbsp&nbsp&nbsp n := if n % 2 == 0 then n / 2 else n * 3 + 1;<br>
										&nbsp&nbsp&nbsp&nbsp }<br>
								}<br>
								å…¶ä¸­ï¼ŒDafnyæä¾›äº†â€œoutâ€œï¼Œç‰¹æ®Šçš„æ³¨è§£ï¼Œdafnyä¸ä¼šè¯•å›¾å»è¯æ˜ç»ˆæ­¢ã€‚ä»¥decreases * æ ‡è®°ã€‚<br>
								ä¸‹é¢ç»™å‡ºå‡ ä¸ªdecreasesä¾‹å­ï¼š
								function Ack(m: nat, n: nat): nat<br>
								decreases m, n<br>
							 {<br>
								&nbsp&nbsp&nbsp&nbsp if m == 0 then n + 1<br>
								&nbsp&nbsp&nbsp&nbsp else if n == 0 then Ack(m - 1, 1)<br>
								&nbsp&nbsp&nbsp&nbsp else Ack(m - 1, Ack(m, n - 1))<br>
							 }<br>
							Termination ä¸ä»…åº”ç”¨åœ¨å•ä¸ªfunctions/methodsä¸Šï¼Œä¹Ÿå¯ä»¥åœ¨å¤šä¸ªç›¸äº’é€’å½’functions/methodsä¸Šã€‚å¦‚ï¼š<br>
							predicate even(n: nat)<br>
							&nbsp&nbsp&nbsp&nbsp ensures even(n) <==> n % 2 == 0<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp if n == 0 then true else odd(n-1)<br>
								}<br>
								predicate odd(n: nat)<br>
								&nbsp&nbsp&nbsp&nbsp ensures odd(n) <==> n % 2 != 0<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp if n == 0 then false else even(n-1)<br>
								}	<br>
							</section>
							<br>

							<section class="post">
								<header class="major">
									<span class="date">Decemeber 10, 2020</span>
									<h1>Dafny å­¦ä¹ ç¼–ç è®°å½•3</h1>
								</header>
								<h3>Sets</h3>
								ä¸åŒç±»å‹çš„Setæ˜¯DafnyéªŒè¯çš„æ ¸å¿ƒå·¥å…·ä¹‹ä¸€ã€‚Setsè¡¨ç¤ºæ²¡æœ‰é‡å¤çš„æ— åºå…ƒç´ é›†åˆã€‚å’ŒSequenceç±»ä¼¼ï¼Œsetæ˜¯ä¸å¯å˜çš„å€¼ç±»å‹ã€‚Setä¸€æ—¦åˆ›å»ºï¼Œä¸èƒ½å†è¢«ä¿®æ”¹ã€‚Setå¯¹æ•´æ•°æœ‰ä»¥ä¸‹ç±»å‹:set<int>ã€‚æ€»çš„æ¥è¯´ï¼Œsetså¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼ŒåŒ…æ‹¬å¯¹è±¡ã€‚å…·ä½“çš„Setå¯ä»¥æ˜¾ç¤ºçš„è¡¨ç¤ºï¼š<br>
									var s1 := {}; // the empty set <br>
									var s2 := {1, 2, 3}; // set contains exactly 1, 2, and 3 <br> 
									assert s2 == {1,1,2,3,3,3,3}; // same as before <br> 
									var s3, s4 := {1,2}, {1,4};	<br>
								å…¶ä»–çš„æ™®é€šçš„é›†åˆæ“ä½œï¼š<br>
								assert s2 + s4 == {1,2,3,4}; // set union <br> 
								assert s2 * s3 == {1,2} && s2 * s4 == {1}; // set intersection <br> 
								assert s2 - s3 == {3}; // set difference <br> 
								å› ä¸ºé›†åˆåªèƒ½ä»…åŒ…å«æœ€å¤šä¸€ä»½æ¯ä¸ªå…ƒç´ ï¼Œunionä¸èƒ½å¤šæ¬¡è®¡ç®—é‡å¤çš„å…ƒç´ ã€‚ä¸¤ä¸ªæœ‰é™é›†åˆæ“ä½œæ•°æ„æˆä¸€ä¸ªæœ‰é™é›†åˆã€‚é›†åˆçš„æ“ä½œç¬¦æ°¸è¿œæœ‰å®šä¹‰ã€‚<br>
								assert {1} <= {1, 2} && {1, 2} <= {1, 2}; // subset <br> 
								assert {} < {1, 2} && !({1} < {1}); // strict, or proper, subset <br> 
								assert !({1, 2} <= {1, 4}) && !({1, 4} <= {1, 4}); // no relation <br> 
								assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; // equality and non-equality <br> 
								é›†åˆå¯ä»¥ç”¨inå’Œï¼inæµ‹è¯•å…ƒç´ åœ¨ä¸åœ¨é›†åˆä¸­ã€‚<br>
								assert 5 in {1,3,4,5};<br> 
								assert 1 in {1,3,4,5};<br> 
								assert 2 !in {1,3,4,5};<br> 
								assert forall x :: x !in {};<br> 
								é›†åˆå¯ä»¥ä½¿ç”¨readså’Œmodifiesæ¡ä¾‹ã€‚å½“ä½¿ç”¨decreaseså­å¥æ˜¯ï¼Œé›†åˆç”±å­é›†æœ‰åºè¡¨ç¤ºã€‚å€ŸåŠ©é›†åˆçš„ç†è§£æ¥åˆ›å»ºé›†åˆã€‚é€šè¿‡åŒ…å«f(x)æ¥ä¸ºæ‰€æœ‰ç±»å‹ä¸ºTçš„xæ»¡è¶³p(x)ï¼š
								<br>   set x: T | p(x) :: f(x)<br>
								ï½œæ˜¯ç”¨æ¥åˆ†ç¦»è°“è¯på’Œæœ‰ç•Œå˜é‡xã€‚ç»“æœé›†çš„å…ƒç´ ç±»å‹å°±æ˜¯f(x)çš„è¿”å›å€¼ç±»å‹ã€‚å¦‚ä¸‹:<br>
								assert (set x | x in {0,1,2} :: x * 1) == {0,1,2}; <br>
								assert (set x | x in {0,1,2,3,4,5} && x < 3) == {0,1,2};<br>
								assert (set x | x in {0,1,2} :: x + 1) == {1,2,3};<br>
							</secition>
							<br>

							<section class="post">
								<header class="major">
									<span class="date">Decemeber 11, 2020</span>
									<h1>Dafny å­¦ä¹ ç¼–ç è®°å½•4</h1>
								</header>
								<h3>Sequences</h3>
								Sequencesæ˜¯Dafnyå†…ç½®çš„ç±»å‹ï¼Œç”¨æ¥è¡¨ç¤ºæœ‰åºçš„åˆ—è¡¨ã€‚ä»–ä»¬å¯ä»¥ç”¨æ¥è¡¨ç¤ºè®¸å¤šæœ‰åºçš„é›†åˆï¼ŒåŒ…æ‹¬listsï¼Œqueueså’Œstacksç­‰ã€‚Sequenceså’ŒSetä¸€æ ·æ˜¯ä¸å¯å˜å€¼ç±»å‹ï¼šä»–ä»¬ä¸€æ—¦åˆ›å»ºä¸å¯ä»¥è¢«ä¿®æ”¹ã€‚åœ¨è¿™ä¸ªè§’åº¦ï¼Œä»–ä»¬ä¸Javaå’ŒPythonä¸­çš„å­—ç¬¦æ˜¯å¾ˆç›¸ä¼¼çš„ï¼Œå‡ºäº†ä»–ä»¬å¯ä»¥æ˜¯ä»»ä¸€ç±»å‹çš„åºåˆ—ã€‚Sequenceç±»å‹å¯ä»¥å¦‚ä¸‹è¡¨ç¤ºï¼š<br>
								seq<int><br>
								ä¸‹é¢å‡½æ•°ä»¥åºåˆ—ä½œä¸ºå‚æ•°ï¼š<br>
								predicate sorted(s: seq<int>) <br>
									{<br>
										&nbsp&nbsp&nbsp&nbsp  forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]<br>
									}<br>
								åºåˆ—çš„é•¿åº¦å†™ä½œ|s|ï¼Œé€šè¿‡æ–¹æ‹¬å·æè¿°è®¿é—®åºåˆ—çš„å…ƒç´ ã€‚å‡½æ•°ä¸éœ€è¦readså­å¥è®¿é—®åºåˆ—ã€‚å› ä¸ºåºåˆ—ä¸åœ¨å †ä¸Šå­˜å‚¨ã€‚ä»–ä»¬åªæ˜¯å€¼ã€‚åºåˆ—æœ€å¼ºå¤§çš„åœ°æ–¹åœ¨äºæ³¨è§£ã€å‡½æ•°å¯ä»¥åˆ›å»ºå¹¶æ“ä½œå®ƒã€‚å¦‚ä¸‹ï¼š<br>
								predicate sorted2(s: seq<int>)<br>
									{<br>
									   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&<br>
												   sorted2(s[1..])<br>
									}<br>
								s[1..]æ˜¯åºåˆ—çš„åˆ‡ç‰‡ï¼Œè¡¨ç¤ºä»ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹ï¼Œç›´åˆ°æœ€åã€‚åˆ‡ç‰‡çš„æ³¨è§£æ˜¯s[i..j]ã€‚æœ€ååºåˆ—æœ‰j-iä¸ªå…ƒç´ ï¼Œä»å…ƒç´ s[j]å¼€å§‹ã€‚å…ƒç´ s[j]ä¸åŒ…å«åœ¨åˆ‡ç‰‡ä¸­ã€‚<br>
								åºåˆ—å¯ä»¥ç”±å…ƒç´ æ„é€ :<br>
								var s := [1, 2, 3];<br>
								var s := [1, 2, 3, 4, 5];<br>
								assert s[|s|-1] == 5; //access the last element<br>
								assert s[|s|-1..|s|] == [5]; //slice just the last element, as a singleton<br>
								assert s[1..] == [2, 3, 4, 5]; // everything but the first<br>
								assert s[..|s|-1] == [1, 2, 3, 4]; // everything but the last<br>
								assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; // the whole sequence<br>
								åºåˆ—ä¹Ÿå¯ä»¥é€šè¿‡ç¬¦å·+æ¥è¿›è¡Œè¿æ¥ã€‚
								assert [1,2,3] == [1] + [2,3];<br>
								assert s == s + [];<br>
								assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];<br>
								åºåˆ—ä¹Ÿæ”¯æŒinå’Œï¼inæ“ä½œï¼Œæµ‹è¯•åŒ…å«ï¼š<br>
								assert 5 in s; // using s from before<br>
								assert 0 !in s;<br>
							</secition>
							<br>
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 11, 2020</span>
									<h1>Dafny å­¦ä¹ ç¼–ç è®°å½•5</h1>
								</header>
								<div class="col-6 col-12-small">
									<h3>Collection Types</h3>
									<ol>
										<li>Sets</li>
										<li>Sequences</li>
										<li>Multisets</li>
										<li>Maps</li>
									</ol>
								</div>
								å€¼ç±»å‹è¡¨ç¤ºä¸€äº›ä¸ä¾èµ–äºå †çŠ¶æ€çš„ä¿¡æ¯ã€‚è¿™äº›å€¼æœ‰ä¸€ä¸ªæ•°å­¦æœ¬èƒ½ï¼šä¸€æ—¦è¢«åˆ›å»ºä¸èƒ½è¢«ä¿®æ”¹ã€‚è¿™äº›ç‰¹æ€§åœ¨è§„çº¦ä¸­å°±æ˜¾å¾—å¾ˆæœ‰ç”¨ã€‚Setsã€Sequencesä¸ä¸Šç›¸åŒã€‚
								<h3>Multisets</h3>
								Multisetså¾ˆå¤šåœ°æ–¹ä¸setsç›¸åŒï¼Œä½†æ˜¯å®ƒèƒ½è·Ÿè¸ªæœ‰å¤šå°‘ä¸ªå…ƒç´ çš„å‰¯æœ¬ã€‚è¿™è®©ä»–åœ¨å­˜å‚¨ä¸€ä¸ªæ•°ç»„çš„å…ƒç´ é›†åˆä¸­æä¸ºæœ‰ç”¨ã€‚æ¯”å¦‚æ¯ä¸ªå…ƒç´ çš„å‰¯æœ¬çš„æ•°é‡éƒ½ç›¸åŒã€‚multisetçš„ç±»å‹ä¸setsç›¸åŒ:<br>
								multiset<int><br>
								Note:multiset({3,3})ä¸æ˜¯ä¸¤ä¸ª3çš„å¤šé‡é›†ã€‚æ‹¬å·å¿…é¡»ä¸å…³é”®è¯è¿æ¥ã€‚<br>
								ä¸setsç›¸åŒï¼Œmultisetsæ˜¯æ— åºçš„ã€‚<br>
								setsä¸Šçš„æ“ä½œå¯¹multisetsä¹Ÿå¯ç”¨ã€‚å¯ä»¥ç”¨inæ¥æµ‹è¯•å…ƒç´ æ˜¯å¦åœ¨multisetä¸­(inè¡¨ç¤ºæœ€å°‘æœ‰ä¸€ä¸ªæˆå‘˜çš„å€¼)ã€‚Multisetçš„å¹¶æ„å‘³è¿™ä»ä¸¤è€…ä¸­å–å…ƒç´ ï¼Œå¹¶ä¸”å°†ä»–ä»¬æ‹¼æ¥èµ·æ¥ã€‚multisetçš„differenceä¹Ÿç±»ä¼¼å·¥ä½œ:<br>
								assert (multiset{1,1,1} - multiset{1,1}) == multiset{1};<br>
								Multisetçš„åˆ†ç¦»ï¼šå¦‚æœä¸¤ä¸ªå¤šé‡é›†æ²¡æœ‰å…¬å…±çš„æˆå‘˜åˆ™ä¸ºçœŸã€‚å½“ä¸”ä»…å½“æ¯ä¸ªå…ƒç´ çš„è®¡æ•°ç›¸ç­‰ï¼Œåˆ™ä¸¤ä¸ªå¤šé‡é›†ç›¸ç­‰ã€‚<br>
								<h3>Maps</h3>
								Dafnyä¸­çš„Mapsè¡¨ç¤ºç»„åˆæ•°ç»„ã€‚å®ƒæœ‰ä¸¤ä¸ªç±»å‹ï¼škeyå’Œtypeã€‚å€¼å¯ä»¥æ ¹æ®keyæå–æˆ–è€…æŸ¥æ‰¾ã€‚mapå†™æˆå¦‚ä¸‹:<br>
								map<U,V><br>
								Uæ˜¯keyï¼ŒVæ˜¯å€¼ã€‚å¯ä»¥æ ¹æ®ç»™å®šçš„keyè®¿é—®å€¼m[key]ã€‚<br>
								æ¯ä¸ªmapéƒ½æœ‰ä¸ªåŸŸï¼Œå³æ‰€æœ‰çš„keyéƒ½æœ‰ä¸€ä¸ªå€¼ã€‚å¦‚æœmæ˜¯ä¸€ä¸ªmapï¼Œé‚£ä¹ˆm[i:=j]æ˜¯ä¸€ä¸ªæ–°çš„mapï¼ŒåŠ äº†iï¼Œjåˆ°mapçš„åŸŸä¸­ã€‚<br>
								Like sets, maps have a map comprehension. The syntax is almost the same as for sets:<br>
								map i: T | p(i) :: f(i)<br>
								å…¶ä¸­ï¼Œiæ˜¯keyï¼Œæœ‰f(i)æ˜ å°„ï¼Œp(i)ç”¨æ¥å†³å®šæ–°mapçš„domainã€‚<br>
								map i | 0 <= i < 10 :: 2*i<br>
								è¡¨ç¤ºä»0åˆ°9ï¼Œvalueæ˜¯å®ƒçš„ä¸¤å€ã€‚<br>
								map i | i in m && i != 3 :: m[i]<br>
								è¡¨ç¤ºä»intåˆ°intçš„map mä¸­ç§»é™¤key=3.<br>
							</secition>
							<br>

							<section class="post">
								<header class="major">
									<span class="date">Decemeber 11, 2020</span>
									<h1>Dafny å­¦ä¹ ç¼–ç è®°å½•6</h1>
								</header>
								<div class="col-6 col-12-small">
									<h3>Lemmas and Induction</h3>
									<ol>
										<li>Introduction</li>
										<li>Searching for Zero</li>
										<li>Lemmas</li>
										<li>Counting</li>
										<li>Proving the Distributive Property</li>
										<li>Induction</li>
										<li>Paths In a Directed Graph</li>
									</ol>
								</div>					
								<h3>Introduction</h3>
								è¯æ˜ç¨‹åºæ­£ç¡®æœ‰æ—¶éœ€è¦é€»è¾‘æ­¥éª¤ï¼Œä½†æ˜¯å¯¹äºDafnyæ¥è¯´å‘ç°è¿™äº›é€»è¾‘è¿‡äºå¤æ‚ã€‚è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬é€šå¸¸æä¾›lemmaæ¥ç»™Dafnyæ´åŠ©ã€‚<br>
								Lemmasæ˜¯ç”¨æ¥è¯æ˜å…¶ä»–ç»“æœçš„å®šç†ï¼Œè€Œä¸æ˜¯æˆä¸ºä¸€ä¸ªç›®æ ‡ã€‚ä»–ä»¬å…è®¸Dafnyå°†è¯æ˜åˆ†æˆï¼šè¯æ˜lemmaï¼Œç„¶åç”¨æ¥è¯æ˜æœ€åçš„ç»“æœï¼›æœ€åçš„ç»“æœæˆä¸ºç¨‹åºçš„æ­£ç¡®æ€§ã€‚Dafnyå’Œè®¡ç®—æœºæ“…é•¿å¤„ç†ç‰¹å®šçš„ç»†èŠ‚å’Œè¦†ç›–æ‰€æœ‰çš„æ¡ˆä¾‹ï¼Œä½†æ˜¯çœ‹ä¸åˆ°ä¸­é—´è¿‡ç¨‹æ¥æ˜¯è¯æ˜è¿‡ç¨‹å˜å¾—ç®€å•ã€‚
								
								é€šè¿‡å†™å’Œä½¿ç”¨lemmasï¼Œä½ å¯ä»¥æŒ‡å‡ºè¿™äº›æ­¥éª¤æ˜¯ä»€ä¹ˆä»¥åŠä»€ä¹ˆæ—¶å€™åœ¨ç¨‹åºä¸­ä½¿ç”¨å®ƒã€‚ä»–ä»¬å¯¹å½’çº³å‚æ•°å¾ˆé‡è¦ï¼Œä¹Ÿæ˜¯å®šç†è¯æ˜å™¨ä¸­æœ€éš¾çš„é—®é¢˜ä¹‹ä¸€ã€‚
								<h3>Searching for Zero</h3>
								é¦–å…ˆçœ‹ä¸€ä¸ªä»æ•°ç»„ä¸­æ‰¾0çš„ä¾‹å­ã€‚è¿™ä¸ªä¾‹å­æœ‰è¶£çš„åœ°æ–¹åœ¨äºæˆ‘ä»¬æœç´¢çš„æ•°ç»„æœ‰ä¸¤ä¸ªç‰¹åˆ«çš„å±æ€§ï¼Œæ‰€æœ‰å…ƒç´ æ˜¯è‚ºè…‘çš„ï¼Œæ¯ä¸ªè¿ç»­çš„å…ƒç´ é€’å‡æœ€å¤šä¸º1ã€‚ä»£ç å¦‚ä¸‹ï¼š<br>
								requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]<br>
								requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]<br>
								æœ‰äº†è¿™äº›å‰æï¼Œæˆ‘ä»¬çš„æœç´¢è·¯å¾„å¯ä»¥åšä¸€äº›èªæ˜çš„äº‹ï¼šè·³è¿‡å…ƒç´ ã€‚è®¾æƒ³æˆ‘ä»¬éå†ä¸€ä¸ªæ•°ç»„ï¼Œçœ‹åˆ°a[j] == 7 é‚£ä¹ˆ 6 <= a[j+1], 5 <= a[j+2]ç­‰ã€‚å®é™…ä¸Šä¸‹ä¸€ä¸ª0ä¸å¯èƒ½è¶…å‡º7ä¸ªå…ƒç´ ã€‚æ‰€ä»¥æˆ‘ä»¬ç”šè‡³ä¸éœ€è¦æœç´¢çŸ¥é“a[j+a[j]]ã€‚<br>
								index := 0;<br>
								while index < a.Length<br>
								   invariant 0 <= index<br>
								   invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0<br>
								{<br>
								   if a[index] == 0 { return; }<br>
								   index := index + a[index];<br>
								}<br>
								index := -1;<br>
								è¿™æ®µä»£ç è®¡ç®—å‡ºæ­£ç¡®çš„ç»“æœï¼Œä½†æ˜¯DafnyæŠ±æ€¨ç¬¬äºŒä¸ªå¾ªç¯ä¸å˜å¼ä¸æˆç«‹ï¼ŒDafnyä¸ä¿¡ä»»æ‰€æœ‰å“ªäº›è·³è¿‡çš„å…ƒç´ æ˜¯åˆç†çš„ã€‚ç†ç”±æ˜¯å‰ç½®æ¡ä»¶è¯´æ¯ä¸ªè¿ç»­çš„å…ƒç´ æœ€å¤šå‡å°‘ä¸€ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰è¯´æ›´è¿œçš„å…ƒç´ æ˜¯å¦‚ä½•å…³è”çš„ã€‚ä¸ºäº†è¯´æœè¿™ä¸ªfactï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸€ä¸ªå¼•ç†ã€‚<br>
								<h3>Lemmas</h3>
								ä¸€ä¸ªlemmaå…¶å®æ˜¯ä¸€ä¸ªghost methodã€‚lemmaçš„åç½®æ¡ä»¶è¡¨ç¤ºæƒ³è¦çš„å±æ€§ã€‚lemmaä¸å…è®¸æ”¹å˜çŠ¶æ€ã€‚å› ä¸ºlemmaæ˜¯ghostçš„ï¼Œä¸èƒ½å†è¿è¡Œæ—¶é—´è¢«è°ƒç”¨ï¼Œæ‰€ä»¥åœ¨äº§ç”Ÿå¯æ‰§è¡Œä»£ç å‰ç¼–è¯‘å™¨ä¼šæ“¦é™¤å®ƒã€‚å› æ­¤ï¼Œå¼•ç†çš„å­˜åœ¨ä»…ä»…æ˜¯ä¸ºäº†å®ƒå¯¹ç¨‹åºéªŒè¯çš„å½±å“ã€‚å¯ä»¥å°†å¼•ç†çœ‹ä¸ºé‡é‡çº§çš„assertionsã€‚ä¸€ä¸ªlemmaå¦‚ä¸‹ï¼š<br>
								lemma Lemma(...)<br>
								ensures (desirable property)<br>
								{<br>
								...<br>
								}<br>
								å¯¹äºé›¶æœç´¢é—®é¢˜ï¼Œæƒ³è¦çš„å±æ€§æ˜¯ç´¢å¼•åœ¨indexåˆ°index+a[index]ä¹‹é—´çš„å…ƒç´ ä¸èƒ½ä¸º0.æˆ‘ä»¬å–æ•°ç»„å’Œå¼€å§‹ç´¢å¼•ä½œä¸ºå‚æ•°ã€‚å¦‚ä¸‹:<br>
								lemma SkippingLemma(a : array<int>, j : int)<br>
									&nbsp&nbsp&nbsp&nbsp requires a != null<br>
									&nbsp&nbsp&nbsp&nbsp requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]<br>
									&nbsp&nbsp&nbsp&nbsp requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]<br>
									&nbsp&nbsp&nbsp&nbsp requires 0 <= j < a.Length<br>
									&nbsp&nbsp&nbsp&nbsp ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0<br>
								 {<br>
									&nbsp&nbsp&nbsp&nbsp ...<br>
								 }<br>
								 åç½®æ¡ä»¶å³æˆ‘ä»¬æƒ³è¦çš„å±æ€§ã€‚å¯¹içš„é™åˆ¶æ˜¯å› ä¸ºj+a[j]æ˜¯æ•°ç»„çš„æœ«ç«¯ã€‚æˆ‘ä»¬åªæƒ³è®¨è®ºè¿™ä¸ªèŒƒå›´å†…çš„ä¸‹æ ‡ï¼Œä¹Ÿå°±æ˜¯æ•°ç»„çš„ä¸‹æ ‡ã€‚ç„¶åæˆ‘ä»¬åšä¸€ä¸ªå…³é”®çš„æ­¥éª¤:æ£€æŸ¥æˆ‘ä»¬çš„å¼•ç†æ˜¯å¦è¶³ä»¥è¯æ˜å¾ªç¯ä¸å˜é‡ã€‚é€šè¿‡åœ¨å¡«å…¥å¼•ç†ä¸»ä½“ä¹‹å‰è¿›è¡Œè¿™ç§æ£€æŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿æˆ‘ä»¬è¯•å›¾è¯æ˜çš„æ˜¯æ­£ç¡®çš„äº‹æƒ…ã€‚FindZeroæ–¹æ³•å˜æˆ:<br>
								 index := 0;<br>
								 while index < a.Length<br>
								 &nbsp&nbsp&nbsp&nbsp invariant 0 <= index<br>
								 &nbsp&nbsp&nbsp&nbsp invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0<br>
								 {<br>
									&nbsp&nbsp&nbsp&nbsp if a[index] == 0 { return; }<br>
									&nbsp&nbsp&nbsp&nbsp SkippingLemma(a, index);<br>
									&nbsp&nbsp&nbsp&nbsp index := index + a[index];<br>
								 }<br>
								 index := -1;<br>
								 æ­¤æ—¶ï¼ŒDafnyå¯¹FindZeroæ²¡æœ‰ä»»ä½•æŠ±æ€¨ã€‚lemmaçš„åç½®æ¡ä»¶è¡¨æ˜ å¾ªç¯ä¸å˜å¼çš„æˆç«‹ã€‚ä½†æ˜¯å®ƒæŠ±æ€¨lemmaæœ¬èº«ï¼Œå› ä¸ºlemmaçš„ä¸»ä½“æ˜¯ç©ºçš„ã€‚ä¸ºäº†è®©Dafnyæ¥å—lemmaï¼Œæˆ‘ä»¬å¿…é¡»è¯æ˜åç½®æ¡ä»¶ä¸ºçœŸã€‚<br>
								 var i := j;<br>
								 while i < j + a[j] && i < a.Length<br>
								 &nbsp&nbsp&nbsp&nbsp invariant i < a.Length ==> a[j] - (i-j) <= a[i]<br>
								 &nbsp&nbsp&nbsp&nbsp invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0<br>
								 {<br>
									&nbsp&nbsp&nbsp&nbsp i := i + 1;<br>
								 }<br>
								 å…¶ä¸­ç¬¬ä¸€ä¸ªä¸å˜å¼æ˜¯å¦‚æœæ²¡æœ‰è¿è¡Œåˆ°æ•°ç»„çš„æœ€åï¼Œå¯¹å½“å‰å…ƒç´ åšäº†çº¦æŸã€‚å¯¹äºè¶…è¿‡jçš„ç´¢å¼•ï¼Œæ•°ç»„åªèƒ½å°ä¸€ä½ï¼Œæ‰€ä»¥è¿™ä¸ªå€¼ä»a[j]ä¸­æå–ã€‚è¿™åªèƒ½è¯´å½“å‰å…ƒç´ ä¸ä¸º0ã€‚å¦‚æœæ²¡æœ‰ç¬¬äºŒä¸ªä¸å˜å¼ï¼ŒDafnyæ— æ³•çŸ¥é“è¿™é‡Œæ²¡æœ‰0.Dafnyå¿˜è®°äº†æ‰€æœ‰å…³äºå¾ªç¯æ‰§è¡Œçš„äº‹æƒ…ï¼Œé™¤äº†invaraintsç”¨çš„ä¸œè¥¿ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å»ºç«‹ä¸€ä¸ªäº‹å®ï¼Œé‚£å°±æ˜¯åˆ°ç›®å‰ä¸ºæ­¢ä»»ä½•åœ°æ–¹éƒ½æ²¡æœ‰é›¶ã€‚<br>
								 <h3>Counting</h3>
								 è®¡ç®—boolåºåˆ—ä¸­trueçš„æ•°é‡ã€‚å¦‚ï¼š<br>
								 function count(a: seq<bool>): nat<br>
									{<br>
										&nbsp&nbsp&nbsp&nbsp if |a| == 0 then 0 else<br>
									   (&nbsp&nbsp&nbsp&nbspif a[0] then 1 else 0) + count(a[1..])<br>
									}<br>
									method m()<br>
									{<br>
										&nbsp&nbsp&nbsp&nbsp assert count([]) == 0;<br>
										&nbsp&nbsp&nbsp&nbsp assert count([true]) == 1;<br>
										&nbsp&nbsp&nbsp&nbsp assert count([false]) == 0;<br>
										&nbsp&nbsp&nbsp&nbsp assert count([true, true]) == 2;<br>
									}<br>
								ä¸Šè¿°ä»£ç ç›´æˆªäº†å½“ï¼Œä½†æ˜¯å‡½æ•°çš„å®šä¹‰æ˜¯é€’å½’çš„ã€‚é€’å½’å‡½æ•°å€¾å‘äºéœ€è¦lemmasã€‚æˆ‘ä»¬æƒ³è¦è¯æ˜ï¼šforall a,b :: count(a+b) == count(a) + count(b)<br>
								å…¶ä¸­ç¬¬ä¸€ä¸ª+æ˜¯åºåˆ—çš„è¿ç»“ï¼Œç¬¬äºŒä¸ª+æ˜¯æ•´æ•°çš„åŠ æ³•ã€‚<br>
								åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­,æˆ‘ä»¬æœ‰ä¸¤ä¸ªé€‰æ‹©å¼•ç†:æˆ‘ä»¬ä¹Ÿå¯ä»¥å†™å…¨ç§°é‡è¯,æˆ–è€…æˆ‘ä»¬å¯ä»¥ä½¿å¼•ç†ç‰¹å®šåºåˆ—aå’Œbã€‚äº‹å®è¯æ˜,å½“æˆ‘ä»¬æƒ³è¦åˆ†é…å¾‹,æˆ‘ä»¬ä¸éœ€è¦å®Œæ•´çš„é€šç”¨å±æ€§ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯ï¼Œå¯¹äºç¨‹åºä¸­å·²çŸ¥çš„ä¸¤ä¸ªç‰¹å®šçš„aå’Œb, count(a + b) == count(a) + count(b)ã€‚å› æ­¤ï¼Œå½“æˆ‘ä»¬è°ƒç”¨å¼•ç†æ¥è·å¾—å±æ€§æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å‘Šè¯‰å®ƒæˆ‘ä»¬å¯¹å“ªä¸¤ä¸ªåºåˆ—æ„Ÿå…´è¶£ã€‚å¦‚æœæˆ‘ä»¬åœ¨å…¶ä»–åœ°æ–¹æœ‰ä¸åŒçš„åºåˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸åŒçš„å‚æ•°è°ƒç”¨è¯¥æ–¹æ³•ï¼Œå°±åƒå¸¸è§„æ–¹æ³•ä¸€æ ·ã€‚è¯æ˜å®Œæ•´çš„æ™®éæ€§è´¨ï¼Œè™½ç„¶æ˜¯å¯èƒ½çš„ï¼Œä½†è¦æ¯”è¯æ˜å…·ä½“çš„ï¼Œå…·ä½“çš„æƒ…å†µåšå¾—æ›´å¤šï¼Œæ‰€ä»¥æˆ‘ä»¬å°†é¦–å…ˆå¤„ç†è¿™ä¸ªæƒ…å†µã€‚<br>
								lemma DistributiveLemma(a: seq<bool>, b: seq<bool>)<br>
									ensures count(a + b) == count(a) + count(b)<br>
								 {<br>
								 }<br>
								 function count(a: seq<bool>): nat<br>
								 {<br>
									if |a| == 0 then 0 else<br>
									(if a[0] then 1 else 0) + count(a[1..])<br>
								 }<br>
								 <h3>Proving the Distributive Property</h3>
								 åœ¨å†™lemmaä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆææ¸…æ¥šè¯æ˜å®ƒçš„ç­–ç•¥ã€‚å‘ç°Dafnyä¸èƒ½è¯æ˜çš„åŸå› æ˜¯countå‡½æ•°æ˜¯ä»åºåˆ—çš„é¦–éƒ¨å¼€å§‹å®šä¹‰çš„ï¼Œè€Œåˆ†å¸ƒå¼å±æ€§åœ¨åºåˆ—çš„ä¸­éƒ¨è¿›è¡Œæ“ä½œã€‚å¦‚æœæˆ‘ä»¬æ‰¾åˆ°ä»åºåˆ—å¤´å¼€å§‹å·¥ä½œï¼Œé‚£ä¹ˆDafnyå¯ä»¥ç›´æ¥ä½¿ç”¨è¿™ä¸ªå‡½æ•°ã€‚å¦‚æœa==[]ï¼Œé‚£ä¹ˆä¸ç®¡bæ˜¯ä»€ä¹ˆï¼Œa+b==bã€‚Lemmaé€šè¿‡isf statementsæ¥è§£å†³æ¡ˆä¾‹ã€‚<br>
								 if a == []<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp assert a + b == b;<br>
									&nbsp&nbsp&nbsp&nbsp assert count(a) == 0;<br>
									&nbsp&nbsp&nbsp&nbsp assert count(a + b) == count(b);<br>
									&nbsp&nbsp&nbsp&nbsp assert count(a + b) == count(a) + count(b);<br>
								}<br>
								else<br>
								{<br>
									&nbsp&nbsp&nbsp&nbsp ...<br>
								}<br>
								å³å¦‚æœa==[]ï¼Œé‚£ä¹ˆlemmaç›´æ¥è¯æ˜äº†åç½®æ¡ä»¶ã€‚å½“0<|a|æ—¶ï¼Œå¦‚ä½•å°†count(a+b) ä¸count(a) å’Œcount(b)ç›¸è¿ã€‚æˆ‘ä»¬é€šè¿‡ä¸‹é¢çš„å°æŠ€å·§æ¥æ‰©å±•countï¼ˆa+bï¼‰:<br>
								assert a + b == [a[0]] + (a[1..] + b);<br>
								assert count(a + b) == count([a[0]]) + count(a[1..] + b);<br>
								æœ€åï¼Œæˆ‘ä»¬æ›¿æ¢countï¼ˆaï¼‰åˆ°åç½®æ¡ä»¶å¾—åˆ°ï¼š<br>
								assert count(a + b) == count(a) + count(b); // postcondition<br>
								assert count(a + b) == count([a[0]]) + count(a[1..]) + count(b);<br>
								<h3>Induction</h3>
								æˆ‘ä»¬å°è¯•çš„å‚æ•°æ˜¯å½’çº³çš„ã€‚æˆ‘ä»¬é€šè¿‡è¯æ˜å°ç‰ˆæœ¬çš„é—®é¢˜æ˜¯çœŸçš„ã€‚è¿™å°±æ˜¯å½’çº³çš„ç²¾ç¡®å®šä¹‰ï¼Œé€šè¿‡ä¸€ä¸ªæ›´å°çš„é—®é¢˜æ¥è¯æ˜å¤§çš„é—®é¢˜ã€‚æˆ‘ä»¬é€šè¿‡è°ƒç”¨é€’å½’å±æ€§ã€‚<br>
								Dafnyä¼šå‡è®¾é€’å½’è°ƒç”¨æ»¡è¶³è§„çº¦ã€‚è¿™æ˜¯å½’çº³å‡è®¾ï¼Œæ‰€æœ‰lemmaçš„é€’å½’è°ƒç”¨æ˜¯åˆç†çš„ã€‚è¿™ä¾èµ–äºDafnyå¦‚ä½•è¯æ˜ç»ˆæ­¢ã€‚åœ¨è¿™ä¸ªå®ä¾‹ä¸­ï¼Œæ˜¯ifè¯­å¥çš„ç¬¬ä¸€ä¸ªåˆ†æ”¯ã€‚å¦‚æœæ²¡æœ‰é€’å½’è°ƒç”¨ï¼Œlemmaå¿…é¡»ç›´æ¥è¯æ˜ã€‚å¦‚æœDafnyä¸èƒ½è¯æ˜è¿™ä¸ªé“¾ç»ˆæ­¢ï¼Œé‚£ä¹ˆè¿™ä¸ªé“¾å°†æ°¸è¿œæ‰§è¡Œï¼Œæ¯æ¬¡è°ƒç”¨çš„å‡è®¾ä¸ä¼šè¢«è¯å®ã€‚
							<br>å½’çº³æ³•ä¸€èˆ¬æ¥è¯´æ˜¯æ‰¾åˆ°ä¸€ç§æ–¹æ³•æ¥é€æ­¥å»ºç«‹ä½ çš„ç›®æ ‡ã€‚è§‚å¯Ÿå…¶ä»–æ–¹æ³•ï¼Œé€šè¿‡å°é—®é¢˜æ¥è¯æ˜ç›®æ ‡ã€‚åˆ†å¸ƒå¼lemmaé€šè¿‡ç»“æ„è¿ç»­çš„åºåˆ—çŸ¥é“ç¬¬ä¸€ä¸ªåºåˆ—å˜æˆç©ºã€‚<br>
							å®ç°è¿™ä¸ªå·¥ä½œçš„å…³é”®æ˜¯Dafnyæ°¸è¿œä¸å¿…è€ƒè™‘æ•´ä¸ªè°ƒç”¨é“¾ã€‚é€šè¿‡æ£€æŸ¥ç»ˆæ­¢ï¼Œå¯ä»¥å¾—åˆ°é“¾æ˜¯æœ‰é™çš„ã€‚ç„¶åå®ƒæ‰€è¦åšçš„å°±æ˜¯æ£€æŸ¥ä¸€ä¸ªæ­¥éª¤ã€‚å¦‚æœä»»æ„ä¸€ä¸ªæ­¥éª¤æ˜¯æœ‰æ•ˆçš„ï¼Œé‚£ä¹ˆæ•´ä¸ªé“¾è‚¯å®šä¹Ÿæ˜¯æœ‰æ•ˆçš„ã€‚è¿™å’ŒDafnyåœ¨å¾ªç¯ä¸­ä½¿ç”¨çš„é€»è¾‘æ˜¯ä¸€æ ·çš„:ä¸€å¼€å§‹æ£€æŸ¥ä¸å˜é‡æ˜¯å¦ä¿æŒä¸å˜ï¼Œç„¶åä»»æ„çš„ä¸€æ­¥ä¿æŒä¸å˜ï¼Œè¿™æ ·ä½ å°±æ£€æŸ¥äº†æ•´ä¸ªå¾ªç¯ï¼Œä¸ç®¡å¾ªç¯è¿è¡Œäº†å¤šå°‘æ¬¡ã€‚ç›¸ä¼¼ä¹‹å¤„ä¸ä»…ä»…æ˜¯è¡¨é¢ä¸Šçš„ã€‚è¿™ä¸¤ç§å¼•ç†(ä»¥åŠDafnyå¯¹ä½ çš„ç¨‹åºæ‰€åšçš„ä¸¤ç§æ¨ç†)éƒ½æ˜¯å½’çº³çš„ã€‚è€ƒè™‘åˆ°è¿­ä»£å’Œé€’å½’ä½œä¸ºè·å¾—åŒä¸€äº‹ç‰©çš„ä¸¤ç§æ–¹æ³•ä¹‹é—´çš„å…³ç³»ï¼Œè¿™ä¹Ÿä¸è¶³ä¸ºå¥‡ã€‚<br>
								lemma DistributiveLemma(a: seq<bool>, b: seq<bool>)<br>
									ensures count(a + b) == count(a) + count(b)<br>
								 {<br>
									&nbsp&nbsp&nbsp&nbspif a == []<br>
									&nbsp&nbsp&nbsp&nbsp {<br>
										&nbsp&nbsp&nbsp&nbsp  assert a + b == b;<br>
										&nbsp&nbsp&nbsp&nbsp }<br>
										&nbsp&nbsp&nbsp&nbsp else<br>
										&nbsp&nbsp&nbsp&nbsp {<br>
											&nbsp&nbsp&nbsp&nbsp   DistributiveLemma(a[1..], b);<br>
											&nbsp&nbsp&nbsp&nbsp  assert a + b == [a[0]] + (a[1..] + b);<br>
											&nbsp&nbsp&nbsp&nbsp }<br>
								 }<br>
								 <h3>Paths in a directed graph</h3>
								 è¿™é‡Œæˆ‘ä»¬è¯æ˜æœ‰å‘å›¾çš„è·¯å¾„ã€‚æœ‰å‘å›¾ç”±ä¸€å®šæ•°é‡çš„ç»“ç‚¹ç»„æˆï¼Œç»“ç‚¹ä¹‹é—´ç”±è¾¹è”ç³»ï¼Œç»“ç‚¹å®šä¹‰ä¸ºï¼š<br>
								 class Node<br>
								{<br>
								// a single field giving the nodes linked to<br>
								var next: seq<Node><br>
								}<br>
								æˆ‘ä»¬ç”¨ä¸€ç»„éç©ºèŠ‚ç‚¹æ¥è¡¨ç¤ºä¸€ä¸ªå›¾ï¼Œè¿™äº›éç©ºèŠ‚ç‚¹åªæŒ‡å‘å›¾ä¸­çš„å…¶ä»–èŠ‚ç‚¹ï¼Œè€Œä¸æŒ‡å‘å®ƒè‡ªå·±ã€‚æˆ‘ä»¬ç§°è¿™æ ·ä¸€ç»„èŠ‚ç‚¹ä¸ºå°é—­çš„:<br>
								predicate closed(graph: set<Node>)<br>
									reads graph<br>
								 {<br>
									null !in graph && // graphs can only consist of actual nodes, not null.<br>
									forall i :: i in graph ==><br>
									   forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i<br>
								 }<br>
								 æˆ‘ä»¬å°†è·¯å¾„è¡¨ç¤ºä¸ºä¸€ä¸ªéç©ºèŠ‚ç‚¹åºåˆ—ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½ç”±è·¯å¾„ä¸­çš„å‰ä¸€ä¸ªèŠ‚ç‚¹é“¾æ¥ã€‚æˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ªè°“è¯ï¼Œä¸€ä¸ªå®šä¹‰æœ‰æ•ˆè·¯å¾„ï¼Œå¦ä¸€ä¸ªç¡®å®šç»™å®šçš„è·¯å¾„æ˜¯å¦ä¸ºå›¾ä¸­ä¸¤ä¸ªç‰¹å®šèŠ‚ç‚¹ä¹‹é—´çš„æœ‰æ•ˆè·¯å¾„:<br>
								 predicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)<br>
									requires closed(graph)<br>
									reads graph<br> 
								 {<br>
									0 < |p| && // path is nonempty<br>
									start == p[0] && end == p[|p|-1] && // it starts and ends correctly<br>
									path(p, graph) // and it is a valid path<br>
								 }<br>
								 predicate path(p: seq<Node>, graph: set<Node>)<br>
									requires closed(graph) && 0 < |p|<br>
									reads graph<br>
								 {<br>
									p[0] in graph &&<br>
									(|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists<br>
									   path(p[1..], graph)) // and the rest of the sequence is a valid<br>
								 }<br>
								 ç°åœ¨æˆ‘ä»¬å‡†å¤‡é™ˆè¿°æˆ‘ä»¬è¦è¯æ˜çš„å¼•ç†ã€‚æˆ‘ä»¬è€ƒè™‘å›¾å’Œå­å›¾:ä¹Ÿæ„æˆå›¾çš„å›¾çš„èŠ‚ç‚¹çš„å­é›†ã€‚è¿™ä¸ªå­å›¾å¿…é¡»æ˜¯å°é—­çš„ï¼Œå³ä¸åŒ…å«å®ƒè‡ªèº«ä¹‹å¤–çš„é“¾æ¥ã€‚å¦‚æœå‡ºç°è¿™ç§æƒ…å†µï¼Œé‚£ä¹ˆä»å­å›¾ä¸­çš„èŠ‚ç‚¹åˆ°å­å›¾å¤–çš„èŠ‚ç‚¹å°±ä¸å­˜åœ¨æœ‰æ•ˆè·¯å¾„ã€‚æˆ‘ä»¬å°†è¿™ä¸ªäº‹å®ç§°ä¸ºé—­å¼•ç†ï¼Œæˆ‘ä»¬åœ¨Dafnyä¸­é™ˆè¿°å¦‚ä¸‹:<br>
							</secition>
							<section class="post">
								<header class="major">
									<span class="date">Decemeber 30, 2020</span>
									<h1>Verifying iterative and recursive programs</h1>
								</header>
								<h3>Initial difficulties</h3>
								Int â€“ nat â€“ real â€“bool; array<br>
								Arrayçš„ç±»å‹æ˜¯å¼•ç”¨ç±»å‹ï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ•°ç»„å…ƒç´ å­˜å‚¨çš„å †åˆ†é…åŒº<br>
								Seqçš„ç±»å‹æ˜¯å€¼ç±»å‹ï¼Œä¸å˜ï¼Œå¯¹Arrayè¿›è¡Œåˆ‡ç‰‡äº§ç”ŸSeqã€‚<br>
								Inv â‰¡ 0 â‰¤ n â‰¤ ğ‘ âˆ§ ğ‘¥ = (âˆ‘i:ğ‘› â‰¤ i<ğ‘:ğ‘‰[ğ‘–])<br>
								<span class="image fit"><img src="images/dafny1.png" alt="" /></span><br>
								<span class="image fit"><img src="images/dafny2.png" alt="" /></span><br>
								<h3>Haskell</h3>
								<span class="image fit"><img src="images/dafny3.png" alt="" /></span><br>

							</secition>
					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>